# 组成原理_数据的表示与运算

- [组成原理_数据的表示与运算](#组成原理_数据的表示与运算)
  - [定点数的表示](#定点数的表示)
    - [无符号数](#无符号数)
    - [有符号数](#有符号数)
  - [运算方法和运算部件](#运算方法和运算部件)
    - [布尔代数和逻辑门](#布尔代数和逻辑门)
    - [基本运算部件](#基本运算部件)
    - [补码的加减法](#补码的加减法)
    - [定点数的移位运算](#定点数的移位运算)
    - [定点数的乘除法](#定点数的乘除法)
  - [浮点数的表示与运算](#浮点数的表示与运算)
    - [浮点数的表示](#浮点数的表示)
    - [浮点数的加减法](#浮点数的加减法)
  - [高级语言中的数据类型](#高级语言中的数据类型)
    - [运算](#运算)
    - [类型转换](#类型转换)

计算机中存储和处理的信息都以二进制的形式表示，原因为：

* 二进制每一位只有两个数值 0 和 1，二值信号可以更加容易、稳定地被物理元件表示，比如电路上的高电平和低电平、磁场的顺时针和逆时针等。
* 二进制的 1 和 0 正好与逻辑值『真』和『假』对应，便于使用[布尔代数](#定点数的表示)进行数字逻辑运算。
* 二进制的编码和运算规则较为简单，通过组合逻辑门电路能够方便地实现算术运算。

关于数据存储的一些概念：

* 计算机中信息量的最小单位，也就是一个二进制位，被称作『比特（bit）』，或直接称为『位』。
* 8 个比特代表一个『字节（byte）』，字节是可寻址的最小内存单位。
* 实际上计算机 CPU 一次处理的数据位数不止 8 位，称这个单位为『字（word）』，一般是字节的整数倍，比如 32 位计算机代表 CPU 一次处理 32 位的数据。
* 字长也称『机器字长』 = ALU 的位数 = CPU 通用寄存器的位数 = 数据总线的宽度
* 存储字长，表示一个存储单元存储的数据位数，一般是字节的整数倍。
* 指令字长，一般是存储字长的整数倍。
* 操作系统位数，操作系统的可寻址位数，小于等于机器字长。比如 32 位 CPU 只能运行 32 位及以下操作系统，不能运行 64 位操作系统。
* 高地址和低地址：在一个内存段中，偏移量大的为高地址，偏移量小的为低地址，或者说内存编号大的是高地址，内存编号小的为低地址。
* 数据的高位和低位：位权高的位为高位，位权低的位为低位。比如 128 的二进制：1000 0000，1000 表示高 4 位，0000 表示低 4 位。
* 数据的高位存储在低地址，称为『大端法』，数据的低位存储在低地址，称为『小端法』。

## 定点数的表示

根据小数点的位置是否固定，将数据分为『定点数』和『浮点数』。小数点位置固定在最低数值位之后，称为『定点整数』，即纯整数。小数点位置固定在最高数值位之前，称为『定点小数』，即纯小数。


在计算机中存在五类定点数编码：

* [无符号数](#无符号数)：用来表示无符号位的定点整数。

* [有符号数](#有符号数)：用来表示带符号位的定点整数和定点小数。
    * 原码
    * 补码
    * 反码
    * 移码

### 无符号数

无符号数，即编码的所有位都是数值位而没有符号位，用来表示自然数。

* 直接将十进制数转化为二进制数，即为该十进制数对应的无符号数编码。

* 如果机器字长为 n，则无符号数编码可以表示 $2^n$ 个真值，表示范围是：$[0, 2^n-1]$。

C 语言中的整数一般默认是带符号的，必须声明为 `unsigned` 才能表示无符号数，如 `unsigned int`、`unsigned short`。

### 有符号数

1. 原码

编码的最高位为符号位，0 表示正，1 表示负，其他位为数值位。

定点整数 x 的 n 位原码： 

$$
[x]_原 = 
\begin{cases}
x&0 \leq x < 2^{n-1} \\
2^{n-1} - x = 2^{n-1} + \left|x\right|&-2^{n-1} <x \leq 0
\end{cases}
$$

> 譬如真值 -7 的 4 位原码为：
>
> $$
> [-7]_原 = 2^{4-1} - (-7) = 8 + 7 = 15 = 1111
> $$

定点小数 x 的原码：

$$
[x]_原 = 
\begin{cases}
x&0 \leq x < 1 \\
1 - x = 1 + \left|x\right|&-1 <x \leq 0
\end{cases}
$$

> 譬如真值 -0.75 的 4 位原码为：
> 
> $$
> [-0.75]_原 = 1 - (-0.75) = 1 + 0.75 = 1.75 = 1.110
> $$

原码的特点：

* 原码就是在真值的首位加上符号位，如果时正数首位就是 0，负数首位就是 1。
* 原码中 0 有两种表示方法：$[+0]_原 = 000...0$ 和 $[-0]_原 = 100...0$。
* 因为 0 有两个原码，所以若机器字长为 n，原码可以表示 $2^{n}-1$ 个整数（或 $2^{n}-1$ 个小数），表示范围 $[-(2^{n-1}-1), 2^{n-1}-1]$。
* $[+x]_原+[-x]_原 \neq [\pm 0]_原$，所以原码的符号位不能直接参与运算，若要实现原码的加减运算需要为此设计复杂的硬件电路，所以计算机中并非使用原码来表示有符号整数。

2. 反码

正数的反码与原码相同，负数的反码为原码符号位不变，数值位按位取反得到。

* 与原码一样，0 的反码有两种表示形式：$[+0]_反 = 000...0，[-0]_反 = 111...1$。
* $[+x]_反+[-x]_反 = 111...1 = [-0]_反$，所以反码的符号位可以参与运算，加法运算将反码相加即可，减法运算将被减数的反码加上减数负数的反码即可。但是反码高位进位时需要进行『循环进位』。
* 曾经的计算机使用过反码表示有符号数，没有补码方便，所以后来使用了补码。

3. 补码

补码通过『模』实现，假设补码的位数为 n，则模为 $2^n$（即最高位的位权）。

> 譬如十进制 0～9 以 10 为模，$-4 \equiv 6 \pmod {10}$。

定点整数 x 的 n 位补码：

$$
[x]_补 = 
\begin{cases}
x& 0 \leq x < 2^{n-1} \\
2^n + x = 2^n - \left|x\right|&-2^{n-1} \leq x \leq 0
\end{cases}\pmod {2^n}
$$

> 譬如真值 -7 的 4 位补码为：
>
> $$
> [-7]_补 = 2^4 + (-7) = 16 - 7 = 9 = 1001
> $$

定点小数 x 的 n 位补码：

$$
[x]_补 = 
\begin{cases}
x& 0 \leq x < 1 \\
2 + x = 2 - \left|x\right|&-1 \leq x \leq 0
\end{cases}\pmod {2}
$$

> 譬如真值 -0.75 的 4 位补码为：
> 
> $$
> [-0.75]_补 = 2 + (-0.75) = 2 - 0.75 = 1.25 = 1.010
> $$

计算补码的方法：

* 直接法：根据上述的公式进行计算。
* 转换法：正数的补码等于真值首位加上符号位 0。负数的补码等于真值的各位取反，末位加 1，首位加上符号位 1。
* 扫描法：正数的补码等于真值首位加上符号位 0，负数的补码等于真值右起第一个 1 的左侧所有位取反，首位加上符号位 1。

由补码计算真值的方法：

* 直接法：补码的首位表示『负位权』，其他位表示『正位权』，按照每位的数值计算即可，譬如 4 位补码 1101：

$$\begin{aligned}
Value &= -1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 \\ &= -8 + 4 + 0 + 1 \\ &= -3
\end{aligned}
$$

* 转换法：正数的补码就是真值，负数的补码各位取反，末位加 1 可得到真值。
* 扫描法：正数的补码就是真值，负数的补码从右起第一个 1 的左侧所有位取反即可得到真值。

补码的特点：

* 0 的补码是唯一的：$[0]_补 = 000...0$，所以相同位数的补码比原码、反码多表示一个数：整数补码多表示一个 $-2^{n-1}$，小数补码多表示一个 -1。
  
  > 譬如 8 位补码可表示整数 $[-128, 127]$、小数 $[-1, 1)$,而 8 位原码、反码仅可以表示整数 $[-127, 127]$、小数 $(-1, 1)$。

* 补码的符号位可直接参与运算，且可以使用一套统一的运算电路实现。所以计算机普遍使用补码表示有符号整数，如 C 语言中的 `signed char`、`int`、`short`、`long` 都是使用补码表示。

变形补码：

模 4 的补码，也称双符号补码，双符号位 00 表示正，11 表示负。

定点小数 x 的 n 位变形补码：

$$
[x]_补 = 
\begin{cases}
x& 0 \leq x < 1 \\
4 + x = 4 - \left|x\right|&-1 \leq x \leq 0
\end{cases}\pmod {4}
$$

> 譬如真值 -0.75 的 4 位变形补码为：
> 
> $$
> [-0.75]_补 = 4 + (-0.75) = 4 - 0.75 = 3.25 = 11.01
> $$

变形补码运算的[溢出](#补码的加减法)检测更容易。

4. 移码

移码只用于表示定点整数，通常用于表示[浮点数](#浮点数的表示)的阶码。

移码的表示方法是真值加上一个常数偏移量（bias），机器字长为 n 时用 $2^{n-1}$ 表示偏移量：

$$
[x]_移 = 2^{n-1} + x \text{ (} -2^{n-1} \leq x < 2^{n-1} \text{)}
$$

> 譬如真值 -7 的 4 位移码为：
> 
> $$
> [-7]_移 = 2^{4-1} + (-7) = 8 - 7 = 1 = 0001
> $$

移码的特点：

* 0 的移码是唯一的：$[0]_移 = 100...0$。
* 移码和补码的差别只有符号位不同，移码的符号位 1 表示正，0 表示负。
* 移码保持了真值原有的大小顺序，移码越大真值越大，移码越小真值越小。

## 运算方法和运算部件

### 布尔代数和逻辑门

布尔代数又称逻辑代数，旨在通过符号化和代数化的计算方法进行逻辑推理。布尔代数是逻辑门电路的数学基础，逻辑门电路是布尔代数的物理实现。

布尔代数只有两个逻辑值： 1 和 0，表示『真』和『假』。

在电路中，一般使用『高电平』表示逻辑真，使用低电平表示逻辑假（也可以反过来表示）。

布尔代数的三种基本运算：

* AND『与』（逻辑乘）：$0 \cdot 0 = 0$，$0 \cdot 1 = 0$，$1 \cdot 0 = 0$，$1 \cdot 1 = 1$。
* OR『或』（逻辑加）：$0 + 0 = 0$，$0 + 1 = 1$，$1 + 0 = 1$，$1 + 1 = 1$。
* NOT『非』（逻辑否定）：$\overline{0} = 1$，$\overline{1} = 0$。

电路的『与门』、『或门』和『非门』，以及『与非门』和『或非门』：

![](image/Pasted%20image%2020220804163450.png)

布尔代数 XOR『异或』运算：

* XOR『异或』：$0\oplus 0 = 0$，$0 \oplus 1 = 1$，$1 \oplus 0 = 1$，$1 \oplus 1 = 0$。

异或可以使用与、或、非实现：

$$X \oplus Y = \overline{X} \cdot Y + X \cdot \overline{Y}$$

在电路中的『异或门』和『异或非门』：

![](image/Pasted%20image%2020220804163626.png)

### 基本运算部件

1. 全加器（Full Adder）

输入端是 $A_i$、$B_i$ 和来自低位的进位 $C_i$，输出端是本为和 $S_i$ 和向高位的进位 $C_i$。

* 本位和 $S_i = A_i \oplus B_i \oplus C_{i-1}$
* 进位 $C_i = A_i \cdot B_i + (A_i \oplus B_i) \cdot C_{i-1}$ 或 $C_i = A_i \cdot B_i + (A_i + B_i) \cdot C_{i-1}$

根据逻辑表达式可以设计出一位全加器的电路：

![](image/Pasted%20image%2020220808103333.png)


使用逻辑表示为；

![](image/Pasted%20image%2020220808103432.png)

2. 串行（行波）进位加法器（Ripple Carry Adder）

将 n 个全加器进行串联即可得到串行进位加法器：

![](image/Pasted%20image%2020220807183859.png)

可实现两个 n 位二进制数 $A = A_nA_{n-1}...A_1$ 和$B = B_nB_{n-1}...B_1$ 逐位相加得到的和 $S = S_nS_{n-1}...S_1$ 和进位 $C_n$。

串行进位加法器高位的全加器必须等待低位计算出进位才能开始运算，位数越多产生的延迟时间就越长。

3. 并行（先行）进位加法器（Carry Look-Ahead Adder）

串行进位加法器所有全加 器不能并行运算，为解决这个问题产生了并行进位加法器。

令 $G_i = A_i \cdot B_I$，$P_i = A_i \oplus B_i$，全加器的进位表达式为：

$$
C_i = G_i + P_i \cdot C_{i-1}
$$

将 $G_i$ 和 $P_i$ 带入 $C_1～C_4$：

$$\begin{aligned}
&C_1 = G_1 + P_1 \cdot C_0\\
&C_2 = G_2 + P_2 \cdot C_1 = G_2 + P_2 \cdot G_1 + P_2 \cdot P_1 \cdot C_0\\
&C_3 = G_3 + P_3 \cdot C_2 = G_3 + P_3 \cdot G_2 +P_3 \cdot P_2 \cdot G_1 + P_3 \cdot P_2 \cdot P_1 \cdot C_0\\
&C_4 = G_4 + P_4 \cdot C_4 = G_4 + P_4 \cdot G_3 + P_4 \cdot P_3 \cdot G_2 + P_4 \cdot P_3 \cdot P_2 \cdot G_1 + P_4 \cdot P_3 \cdot P_2 \cdot P_1 \cdot C_0 
\end{aligned}
$$

也就是说 $C_i$ 只与 $A_i$、$B_i$ 和 $C_0$ 有关，而与各位之间的进位无关。设计额外的组成逻辑电路提前计算出各位全加器所需的进位输入，此电路称为先行进位部件（CLA）。通过先行进位部件，每一位的进位是并行产生的。

为避免电路过于复杂，通常按照 4 位一组进行先行进位。

> 例如 16 位加法器，可分为 4 组，组内的 4 位先行进位，组间串行进位。  
> 为了进一步提高运算速度，可使组间也进行并行进位。

4. 算术逻辑单元（ALU）

### 补码的加减法

1. 补码的加减法运算

n 位补码的加减法：

$$\begin{aligned}
&[A+B]_补 = [A]_补 + [B]_补 \pmod {2^n} \\
&[A-B]_补 = [A]_补 + [-B]_补 \pmod {2^n}
\end{aligned}
$$

注意到当 B 等等于 $-2^{n-1}$ 时，-B 的值超出了补码的表示范围，此时使用 B 本身相加。

补码加减法的运算电路：

2. 溢出（overflow）检测

* 根据操作数与运算结果的符号位是否一至判断

只有两个符号位相同的数相加才会发生溢出，即设两操作数的符号位为 $A_s$ 和 $B_s$，运算结果的符号位为  $S_s$：

$$
V = A_s \cdot B_s \cdot \overline{S_s} + \overline{A_S} \cdot \overline{B_s} \cdot S_s 
$$

* 根据标志位 OF

$$
OF = C_n \oplus C_{n-1}
$$

* 采用双符号位

若双符号位的数值相同，则未溢出，否则溢出。

### 定点数的移位运算

1. 逻辑移位

* 用于无符号数的移位。
* 左移和右移均补 0：

```c
unsigned char i = 1; // 01H，即 00000001B
i >> 1; // 00H，即 00000000B
i << 1; // 02H，即 00000010B
```

2. 算术移位

* 用于补码的移位。
* 左移和右移动均补符号位：

```c
signed char i = 2, j = -2; // i：02H，即 00000010B，j：feH，即 11111110B
i >> 1; // 01H，即 00000001B
i << 1; // 04H，即 00000100B
j >> 1; // ffH，即 11111111B
i << 1; // fdH，即 11111101B
```

### 定点数的乘除法

1. 原码的一位乘法

n 位原码 $[X]_原 = x_1x_2...x_n$ 和 $[Y]_原 = y_1y_2...y_n$ 相乘，得到积为 $[P]_原 = p_1p_2...p_n$：

* 两数取绝对值当作无符号数相乘，$\left| P \right| =\left| X \right|\left| Y \right|$。符号位不参与乘法运算，$p_1= x_1 \oplus y_1$。

> 通过小学学习的乘法知识可知，乘法其实是乘数的各位（从最低位开始）与被乘数相乘并移位求和的结果，假设每一次移位求和的结果称为『部分积』，最初的部分积 $P_0 = 0$。

* 从乘数的最后一位 $y_n$ 开始，乘被乘数并与部分积相加得到新的部分积 $P_i = P_{i-1} + y_{n-i}\left|X\right|$，然后部分积右移 1 位。
* 循环上一个过程直到乘数的每一位都参与了运算为止。

原码乘法的运算电路：

2. 补码的一位乘法

补码乘法的运算电路：

3. 原码的除法

原码除法的运算电路：

4. 补码的除法

补码除法的运算电路：

## 浮点数的表示与运算

### 浮点数的表示

### 浮点数的加减法

## 高级语言中的数据类型

```c
#include <stdio.h>
#define SHOW(X) show_byte((unsigned char *)&(X), sizeof (X));

void show_byte(unsigned char *p, size_t size) {
    for (int i = 0; i < size; ++i)
        printf("%.2x ", p[i]);
    printf("\n");
}
```

这是一段 C 语言代码，`SHOW(X)` 可以输出 `X` 在内存中的编码。

### 运算

### 类型转换

1. 自动类型转换

2. 隐式强制类型转换

3. 显式强制类型转换


窄化和溢出：

```c

```

